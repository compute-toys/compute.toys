

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";






-- CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA "pgsodium";








ALTER SCHEMA "public" OWNER TO "postgres";


CREATE EXTENSION IF NOT EXISTS "http" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."visibility" AS ENUM (
    'private',
    'unlisted',
    'public'
);


ALTER TYPE "public"."visibility" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_private"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$

declare new_username text;

begin

  new_username := new.raw_user_meta_data->>'username';

  

  if exists (select username, email from public.user where (username = new_username or email = new.email)) 

  then

      raise exception 'Username or email already exists';

  end if;

  

  if exists (select username from public.profile where (username = new_username)) 

  then

      raise exception 'Username or email already exists';

  end if;

  

  insert into public.user (id, email, username)

  values (new.id, new.email, new_username);

  

  insert into public.profile (id, username)

  values (new.id, new_username);

  

  return new;

end;

$$;


ALTER FUNCTION "public"."handle_new_user_private"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_discord"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
declare
  shader_url text;
  json_payload text;
  response_record record;
begin
  -- Construct the shader URL
  shader_url := 'https://compute.toys/view/' || new.id;

  -- Create the JSON payload as text
  json_payload := '{"content": "A new shader has been made public: ' || shader_url || '"}';

  -- Perform the HTTP POST request using pgsql-http
--   select
--     "status", "content"::jsonb
--   into response_record
--   from
--     http_post(
--       'https://discord.com/api/webhooks/XXXXXXXXXXXXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
--       json_payload,
--       'application/json'
--     );

  -- Optionally, you can handle the response or log it if needed
  -- Example: raise notice 'Status: %, Response: %', response_record.status, response_record.content;

  return new;
end;
$$;


ALTER FUNCTION "public"."notify_discord"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_user_on_add_shader"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$

BEGIN

  IF NEW.author IS NULL THEN

    NEW.author := auth.uid();

  END IF;

  RETURN NEW;

END;

$$;


ALTER FUNCTION "public"."set_user_on_add_shader"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."profile" (
    "id" "uuid" NOT NULL,
    "username" character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "about" character varying,
    "avatar_url" character varying
);


ALTER TABLE "public"."profile" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shader" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" character varying(32) NOT NULL,
    "description" character varying(255),
    "license" "text",
    "body" "jsonb" NOT NULL,
    "author" "uuid" NOT NULL,
    "visibility" "public"."visibility" DEFAULT 'private'::"public"."visibility" NOT NULL,
    "thumb_url" character varying
);


ALTER TABLE "public"."shader" OWNER TO "postgres";


ALTER TABLE "public"."shader" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."shader_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."user" (
    "id" "uuid" NOT NULL,
    "email" character varying NOT NULL,
    "username" character varying
);


ALTER TABLE "public"."user" OWNER TO "postgres";


ALTER TABLE ONLY "public"."profile"
    ADD CONSTRAINT "profile_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profile"
    ADD CONSTRAINT "profile_username_key" UNIQUE ("username");



ALTER TABLE ONLY "public"."shader"
    ADD CONSTRAINT "shader_id_key" UNIQUE ("id");



ALTER TABLE ONLY "public"."shader"
    ADD CONSTRAINT "shader_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user"
    ADD CONSTRAINT "user_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."user"
    ADD CONSTRAINT "user_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user"
    ADD CONSTRAINT "user_username_key" UNIQUE ("username");



CREATE OR REPLACE TRIGGER "set_user_on_add_shader_trigger" BEFORE INSERT ON "public"."shader" FOR EACH ROW EXECUTE FUNCTION "public"."set_user_on_add_shader"();



CREATE OR REPLACE TRIGGER "shader_visibility_public_insert_webhook" AFTER INSERT ON "public"."shader" FOR EACH ROW WHEN (("new"."visibility" = 'public'::"public"."visibility")) EXECUTE FUNCTION "public"."notify_discord"();



CREATE OR REPLACE TRIGGER "shader_visibility_public_webhook" AFTER UPDATE OF "visibility" ON "public"."shader" FOR EACH ROW WHEN ((("new"."visibility" = 'public'::"public"."visibility") AND ("old"."visibility" <> 'public'::"public"."visibility"))) EXECUTE FUNCTION "public"."notify_discord"();



ALTER TABLE ONLY "public"."profile"
    ADD CONSTRAINT "profile_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."profile"
    ADD CONSTRAINT "profile_username_fkey" FOREIGN KEY ("username") REFERENCES "public"."user"("username");



ALTER TABLE ONLY "public"."shader"
    ADD CONSTRAINT "shader_author_fkey" FOREIGN KEY ("author") REFERENCES "public"."profile"("id");



ALTER TABLE ONLY "public"."user"
    ADD CONSTRAINT "user_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id");



CREATE POLICY "Authenticated users can add a shader." ON "public"."shader" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Grant access to profile table to supabase_auth_admin" ON "public"."profile" TO "supabase_auth_admin" USING (true) WITH CHECK (true);



CREATE POLICY "Grant access to user table to supabase_auth_admin" ON "public"."user" TO "supabase_auth_admin" USING (true) WITH CHECK (true);



CREATE POLICY "Public and unlisted shaders are viewable by everyone." ON "public"."shader" FOR SELECT USING ((("visibility" = 'public'::"public"."visibility") OR ("visibility" = 'unlisted'::"public"."visibility") OR (("visibility" = 'private'::"public"."visibility") AND ("auth"."uid"() = "author"))));



CREATE POLICY "Public profiles are viewable by everyone." ON "public"."profile" FOR SELECT USING (true);



CREATE POLICY "Users can delete their own shader" ON "public"."shader" FOR DELETE USING (("auth"."uid"() = "author"));



CREATE POLICY "Users can insert their own profile." ON "public"."profile" FOR INSERT WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Users can update own profile." ON "public"."profile" FOR UPDATE USING (("auth"."uid"() = "id"));



CREATE POLICY "Users can update their own shader." ON "public"."shader" FOR UPDATE USING (("auth"."uid"() = "author"));



ALTER TABLE "public"."profile" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shader" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";








REVOKE USAGE ON SCHEMA "public" FROM PUBLIC;
GRANT ALL ON SCHEMA "public" TO PUBLIC;
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";


































































































































































































































































































































































































































































GRANT ALL ON FUNCTION "public"."handle_new_user_private"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_private"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_private"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_discord"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_discord"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_discord"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_user_on_add_shader"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_user_on_add_shader"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_user_on_add_shader"() TO "service_role";
























GRANT ALL ON TABLE "public"."profile" TO "anon";
GRANT ALL ON TABLE "public"."profile" TO "authenticated";
GRANT ALL ON TABLE "public"."profile" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."profile" TO "supabase_auth_admin";



GRANT ALL ON TABLE "public"."shader" TO "anon";
GRANT ALL ON TABLE "public"."shader" TO "authenticated";
GRANT ALL ON TABLE "public"."shader" TO "service_role";



GRANT ALL ON SEQUENCE "public"."shader_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."shader_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."shader_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."user" TO "anon";
GRANT ALL ON TABLE "public"."user" TO "authenticated";
GRANT ALL ON TABLE "public"."user" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user" TO "supabase_auth_admin";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






























RESET ALL;
